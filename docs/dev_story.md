### 2014-05-05

从今天开始写下开发故事，呵呵。

这个项目的起因是因为公司有一个文档系统，大家都用它来保存一些临时的文本，以便在不同的
机器之前共享信息。
但最近这个应用经常响应很慢，占很高的CPU，因为该应用是用
[Meteor](https://github.com/meteor/meteor)
开发的，自带了mongoDB,nodeJS，内部原理比较复杂，一时半会儿没找到响应慢的原因。

所以我就用web.py开始写一个纯粹的剪贴板程序，顺便学一学web.py。以前的文档系统不能够
保存修改历史，这次开发剪贴板程序时特地实现了保存所有历史的功能。

web.py确实是简单而强大，能够很快速的写一些数据驱动的小应用，自带的db模块能够很方便的
进行数据库操作，接口设计的很简洁直观，很容易记住，和直接写SQL语句差不多，但用python
函数来生成SQL又比直接写SQL简单了不少。还有一些很贴心的地方，比如如果一个表有自增列，
那么db.insert返回的就是刚刚插入自增ID，这样可以很方便的继续做一些关联的操作。

前端界面先用Bootstrap快速搞了一个，以前都是瞎用，五一花了一些时间把Bootstrap的文档
详细看了一遍，就差插件部分没有完整看完了。但真正要用Bootstrap写一个应用时，还是会
遇到很多布局问题，怎么看怎么难看，主导航，次导航，面包屑，页面标题，按钮条等安排想
来想去都觉得不好，看起来巨不专业，先不纠结了。

前端框架计划用Angularjs，强大的双向绑定功能应该能减少很多代码，不过我现在还基本不会
用呢，所以做这个剪贴板程序时，一行Javascript代码也没写，其实很早以前写asp程序时是
很少用JS脚本的，数据都是通过Form来POST上来的，后来因为Ajax的流行，所有和服务器的数据
交换都用JS来做，差点都忘了普通的表单提交了，这次返璞归真，直接用Form来提交数据，不
实现无刷新的效果。

还有一些安全问题是必须要考虑的，小程序刚发布出来，同事就问我剪贴板内容是用什么字段
保存的，我说是TEXT类型，他就说输入有没有限制长度，会不会有人提交几十兆的文本来把
数据库刷爆。所以我写了个web.py的loadhook限制每一个web.input字段大小都不能超过10240
个字节，先整体过滤一把再说。

sql注入的问题应该不用考虑，从接口使用上看web.py的db模块应用用的是参数化查询，不是
拼接的SQL字符串。

xss注入应该也不需要考虑，web.py模板默认输出变量是经过web.websafe过滤的，尖括号都被
转义了。

就是csrf问题还得人工解决一下，到时候参考[这个链接](http://webpy.org/cookbook/csrf)

现在的剪贴板完全是公开的，所以打算做一个用户注册系统，登陆后可以写一些私有的文字。
有了用户注册系统后，再搞个短消息系统，用户间能够互发消息，管理员也可以给所有人发消息
，然后再做个微博系统，用户可以每天在上面发个微博啥的，最后应该是Todo,Bug管理，需求
管理，通讯录，论坛，借书，申请会议室, 客户管理等功能都搞出来，哈哈，到时候再说，囧。

这些东西其实没什么技术含量，新手学下数据库增删改查都能做出来。但一些子系统需求比较
复杂，细节也比较多，做起来比较麻烦，就当练习一下编码了，开源软件也没必要高大上，做
一些能解决小问题的小东西也行。去年看的《程序员的职业素养》里说，程序员要不断的刻意
练习来提高自己的技艺，天天开车也不会成为赛车手，所以业余时间还要做一些练习的事情。

因为大多人都会计较一个应用好用不好用，好看不好看，而且每个人对这些事情的理解都不一样
，所以这个系统不太会关注好用和好看的事情。我主要是实现每个系统的model层和逻辑层，然
后发布成web api，界面草草做一个就行，如果有人觉得不爽，就自己搞表现层和交互就行了。
刚看了《程序员修炼之道》里的 “石头汤”的故事，好多人乐于参与正在发生的成功，所以
先把东西起个头，做出来，让大家看到他的价值，就自然有善于前端和设计的人加入进来了。


做开源项目得有一些讲究，先列个清单：

== 单元测试

这个必须有，虽然测试不会比Code Review更容易发现BUG，但测试是代码能够正确
运行的保证，主要是让别人看的，让别人信任你这个系统。

里面还是有很多纠结的地方，使用
nose还是py.test，测试用例是写在本文件里，还是单独的test目录里，还是直接写doctest。
先用nose了，具体写在哪儿，简单的就写doctest，很少依赖别的模块的模块的测试就写在本
模块里，那些需要协调很多个模块的测试用例就单独起一个文件来写。最后写一个nose脚本
来一起执行所有的测试。

覆盖率也得搞上，虽不追求100%的覆盖，但至少心里有个底儿，其实你写的每一行代码都是
有意义的，对吧。

== 代码结构

考虑这个问题，老遭罪了，想过很多种方案，都有不同的缺点和优点，有的目录太深，看起来
太复杂，有的都放在一起，看起来也很乱，甚至以前还做了一个pyempty的小项目来规范一个
新python项目的目录结构，其实主要也是借鉴github上的开源项目。

所以先不考虑特别多了，根目录下就docs,tests,www三个目录，外加requirements.txt，
Mackfile，README.md,这都是必须的，不能再简了。

至于www下考虑的就多了，囧。最终决定一个app一个文件吧，就在www下，不再设置子目录了，
然后这个app的数据库操作，业务逻辑，web api等都写在一个文件里，因为每个app应该很小
，所以写在一个文件里也不会太长。

然后每个app里可能还会用一些公共的函数，都放到utils里，也在同一个目录下，可以直接
import，如果app在www的子目录里，里面再放些model.py,views.py,app.py等，那再想使用
utils就麻烦了，得`sys.path.append('..')`, 或者`from .. import utils`,或者修改
`sys.modules`，可以说每种方案都不够优雅。

== 编码风格

直接用flake8，风格检查，语法检查，复杂度检查都有了，vim里也有相关插件，经常检查下，
防止破窗户产生。


== git分支使用

一直以来对git的使用还停留在add, commit, push的层次上。但人家开源项目的master分支的
历史看起来很简洁有用，还有各种tag，每个Tag里都有整齐的ChangeList，所以我也想做到。
先熟悉下git merge的各个参数再说，之前用git flow，虽然正统，但感觉太复杂，得自己总结
一套更简单的。 // TODO: 

== 关于部署

因为是一个web app，所以我觉得没必要打包都pypi吧，直接git clone下来就行。
初步计划大体步骤应该是如下

1. pip install -r requirements.txt`安装依赖
1. 执行 ./docs/install.sql 初始化数据库
1. make test 进行测试验证
1. make run 启动应用

当然安装Python, pip, 配置Gunicorn,nginx等就是使用者自己折腾下的事了，囧。
